Oto rozszerzona aplikacja z pe≈ÇnƒÖ funkcjonalno≈õciƒÖ zarzƒÖdzania czatami i plikami ZIP:

python
import os
import time
import requests
import pyperclip
import json
import re
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
from datetime import datetime
from pathlib import Path
from urllib.parse import unquote, urlparse
import zipfile
import webbrowser

class ChatManagerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("AI Chat & File Manager")
        self.root.geometry("1000x800")
        self.root.resizable(True, True)
        
        # Konfiguracja stan√≥w
        self.monitoring = False
        self.chat_logging = False
        self.chat_history = []
        self.last_clip = ""
        self.downloaded_zips = []
        self.loaded_chats = []
        
        # Tworzenie zak≈Çadek
        self.notebook = ttk.Notebook(root)
        self.notebook.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Zak≈Çadka Monitorowanie
        self.monitor_tab = self.create_monitor_tab()
        
        # Zak≈Çadka Archiwum Czat√≥w
        self.archive_tab = self.create_archive_tab()
        
        # Zak≈Çadka ZarzƒÖdzanie Plikami
        self.files_tab = self.create_files_tab()
        
        # Status bar
        self.status_bar = tk.Label(root, text="Gotowy", bd=1, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Uruchom g≈Ç√≥wnƒÖ pƒôtlƒô
        self.update_clipboard()
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def create_monitor_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Monitorowanie")
        
        # Stylizacja
        button_style = {"font": ("Arial", 10), "bg": "#4CAF50", "fg": "white", "height": 1, "width": 15}
        frame_style = {"bd": 2, "relief": "groove", "padx": 10, "pady": 10, "bg": "white"}
        
        # Funkcje ZIP
        zip_frame = tk.LabelFrame(tab, text="üì¶ Pobieranie ZIP", **frame_style)
        zip_frame.pack(fill="x", padx=10, pady=5)
        
        tk.Button(zip_frame, text="üöÄ Start Monitoring", command=self.start_monitoring, **button_style).pack(side="left", padx=5, pady=5)
        tk.Button(zip_frame, text="‚èπÔ∏è Stop", command=self.stop_monitoring, **button_style).pack(side="left", padx=5, pady=5)
        tk.Label(zip_frame, text="Status:", bg="white").pack(side="left", padx=5)
        self.zip_status = tk.Label(zip_frame, text="Nieaktywny", fg="red", bg="white")
        self.zip_status.pack(side="left", padx=5)
        
        # Funkcje czatu
        chat_frame = tk.LabelFrame(tab, text="üí¨ Logowanie Czatu", **frame_style)
        chat_frame.pack(fill="x", padx=10, pady=5)
        
        tk.Button(chat_frame, text="üìù Start Logging", command=self.start_chat_logging, **button_style).pack(side="left", padx=5, pady=5)
        tk.Button(chat_frame, text="‚èπÔ∏è Stop Logging", command=self.stop_chat_logging, **button_style).pack(side="left", padx=5, pady=5)
        tk.Button(chat_frame, text="üíæ Zapisz Czat", command=self.save_chat, **button_style).pack(side="left", padx=5, pady=5)
        tk.Label(chat_frame, text="Status:", bg="white").pack(side="left", padx=5)
        self.chat_status = tk.Label(chat_frame, text="Nieaktywny", fg="red", bg="white")
        self.chat_status.pack(side="left", padx=5)
        
        # Wy≈õwietlacz czatu
        self.chat_display = scrolledtext.ScrolledText(tab, wrap=tk.WORD, font=("Arial", 10))
        self.chat_display.pack(fill="both", expand=True, padx=10, pady=5)
        self.chat_display.insert(tk.END, "Historia czatu bƒôdzie wy≈õwietlana tutaj...\n")
        self.chat_display.configure(state="disabled")
        
        return tab
    
    def create_archive_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Archiwum Czat√≥w")
        
        frame_style = {"bd": 2, "relief": "groove", "padx": 10, "pady": 10, "bg": "white"}
        button_style = {"font": ("Arial", 10), "bg": "#2196F3", "fg": "white", "height": 1, "width": 20}
        
        # Panel wczytywania
        load_frame = tk.LabelFrame(tab, text="üìÇ Wczytaj historiƒô czatu", **frame_style)
        load_frame.pack(fill="x", padx=10, pady=5)
        
        tk.Button(load_frame, text="Otw√≥rz plik czatu", command=self.load_chat_file, **button_style).pack(side="left", padx=5, pady=5)
        tk.Button(load_frame, text="Otw√≥rz katalog", command=self.open_chat_directory, **button_style).pack(side="left", padx=5, pady=5)
        
        # Lista za≈Çadowanych czat√≥w
        self.chat_listbox = tk.Listbox(tab, height=10)
        self.chat_listbox.pack(fill="both", expand=True, padx=10, pady=5)
        self.chat_listbox.bind('<<ListboxSelect>>', self.display_selected_chat)
        
        # Panel eksportu
        export_frame = tk.LabelFrame(tab, text="üì§ Eksport czatu", **frame_style)
        export_frame.pack(fill="x", padx=10, pady=5)
        
        tk.Button(export_frame, text="Eksportuj do GPT", command=self.export_to_gpt, **button_style).pack(side="left", padx=5, pady=5)
        tk.Button(export_frame, text="Kopiuj do schowka", command=self.copy_chat_to_clipboard, **button_style).pack(side="left", padx=5, pady=5)
        
        return tab
    
    def create_files_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="ZarzƒÖdzanie Plikami")
        
        frame_style = {"bd": 2, "relief": "groove", "padx": 10, "pady": 10, "bg": "white"}
        button_style = {"font": ("Arial", 10), "bg": "#FF9800", "fg": "white", "height": 1, "width": 25}
        
        # Panel wyszukiwania ZIP
        zip_frame = tk.LabelFrame(tab, text="üì¶ Znajd≈∫ pliki ZIP w czatach", **frame_style)
        zip_frame.pack(fill="x", padx=10, pady=5)
        
        tk.Button(zip_frame, text="Skanuj wszystkie czaty", command=self.scan_all_chats_for_zips, **button_style).pack(side="left", padx=5, pady=5)
        tk.Button(zip_frame, text="Pobierz wszystkie", command=self.download_all_zips, **button_style).pack(side="left", padx=5, pady=5)
        
        # Lista znalezionych ZIP
        self.zip_listbox = tk.Listbox(tab, height=10)
        self.zip_listbox.pack(fill="both", expand=True, padx=10, pady=5)
        
        # Panel zarzƒÖdzania plikami
        file_frame = tk.LabelFrame(tab, text="üóÇÔ∏è ZarzƒÖdzanie pobranymi plikami", **frame_style)
        file_frame.pack(fill="x", padx=10, pady=5)
        
        tk.Button(file_frame, text="Otw√≥rz folder z ZIP", command=self.open_zip_directory, **button_style).pack(side="left", padx=5, pady=5)
        tk.Button(file_frame, text="Poka≈º ≈õcie≈ºki w konsoli", command=self.show_zip_paths, **button_style).pack(side="left", padx=5, pady=5)
        tk.Button(file_frame, text="Rozpakuj wybrany ZIP", command=self.extract_selected_zip, **button_style).pack(side="left", padx=5, pady=5)
        
        return tab

    def start_monitoring(self):
        self.monitoring = True
        self.zip_status.config(text="Aktywny", fg="green")
        self.update_status("Monitorowanie ZIP w≈ÇƒÖczone")

    def stop_monitoring(self):
        self.monitoring = False
        self.zip_status.config(text="Nieaktywny", fg="red")
        self.update_status("Monitorowanie ZIP wy≈ÇƒÖczone")

    def start_chat_logging(self):
        self.chat_logging = True
        self.chat_status.config(text="Aktywny", fg="green")
        self.update_status("Logowanie czatu w≈ÇƒÖczone")
        self.add_chat_entry("System", "Rozpoczƒôto logowanie czatu")

    def stop_chat_logging(self):
        self.chat_logging = False
        self.chat_status.config(text="Nieaktywny", fg="red")
        self.update_status("Logowanie czatu wy≈ÇƒÖczone")
        self.add_chat_entry("System", "Zatrzymano logowanie czatu")

    def download_zip(self, url):
        try:
            # Oczyszczanie nazwy pliku z URL
            filename = unquote(url.split("/")[-1])
            if not filename.endswith('.zip'):
                filename += '.zip'
            
            # Tworzenie folderu pobierania
            download_dir = Path.home() / "zip_downloads"
            download_dir.mkdir(exist_ok=True)
            file_path = download_dir / filename
            
            # Sprawd≈∫ czy plik ju≈º istnieje
            if file_path.exists():
                self.update_status(f"Plik ju≈º istnieje: {file_path}")
                self.downloaded_zips.append(str(file_path))
                return True
            
            # Pobieranie pliku
            self.update_status(f"Pobieranie: {url}")
            response = requests.get(url, stream=True)
            response.raise_for_status()
            
            with open(file_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            self.update_status(f"Zapisano: {file_path}")
            self.downloaded_zips.append(str(file_path))
            return True
            
        except Exception as e:
            self.update_status(f"B≈ÇƒÖd: {str(e)}")
            return False

    def add_chat_entry(self, role, content):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        entry = {
            "timestamp": timestamp,
            "role": role,
            "content": content
        }
        self.chat_history.append(entry)
        
        # Aktualizacja wy≈õwietlacza
        self.chat_display.configure(state="normal")
        self.chat_display.insert(tk.END, f"[{timestamp}] {role}:\n{content}\n\n")
        self.chat_display.configure(state="disabled")
        self.chat_display.yview(tk.END)

    def save_chat(self):
        try:
            if not self.chat_history:
                messagebox.showinfo("Info", "Brak historii czatu do zapisania")
                return
                
            chat_dir = Path.home() / "chat_history"
            chat_dir.mkdir(exist_ok=True)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            file_path = chat_dir / f"chat_{timestamp}.txt"
            
            with open(file_path, 'w', encoding='utf-8') as f:
                for entry in self.chat_history:
                    f.write(f"[{entry['timestamp']}] {entry['role']}:\n")
                    f.write(f"{entry['content']}\n\n")
            
            self.update_status(f"Zapisano historiƒô czatu: {file_path}")
            messagebox.showinfo("Sukces", f"Historia czatu zapisana w:\n{file_path}")
            
            # Dodaj do listy za≈Çadowanych czat√≥w
            self.loaded_chats.append({
                "path": str(file_path),
                "content": self.get_chat_content()
            })
            self.update_chat_listbox()
            
        except Exception as e:
            messagebox.showerror("B≈ÇƒÖd", f"Nie uda≈Ço siƒô zapisaƒá czatu: {str(e)}")
    
    def get_chat_content(self):
        return "\n".join(
            f"[{entry['timestamp']}] {entry['role']}:\n{entry['content']}" 
            for entry in self.chat_history
        )

    def update_status(self, message):
        self.status_bar.config(text=message)
        print(message)

    def update_clipboard(self):
        try:
            current_clip = pyperclip.paste().strip()
            
            # Monitorowanie ZIP
            if (self.monitoring and 
                current_clip != self.last_clip and 
                current_clip.startswith(('http://', 'https://')) and 
                '.zip' in current_clip.lower()):
                
                if self.download_zip(current_clip):
                    self.last_clip = current_clip
                else:
                    self.last_clip = ""
            
            # Monitorowanie czatu
            if (self.chat_logging and 
                current_clip != self.last_clip and 
                current_clip and 
                len(current_clip) > 10):
                
                # Automatyczne wykrywanie roli
                role = "User"
                if any(phrase in current_clip for phrase in ["Assistant:", "AI:", "ChatGPT:", "DeepSeek:"]):
                    role = "Assistant"
                
                self.add_chat_entry(role, current_clip)
                self.last_clip = current_clip
        
        except Exception as e:
            self.update_status(f"B≈ÇƒÖd monitorowania: {str(e)}")
        
        self.root.after(1000, self.update_clipboard)

    def on_closing(self):
        if self.chat_logging:
            self.stop_chat_logging()
        self.root.destroy()
    
    # Funkcje archiwum czat√≥w
    def load_chat_file(self):
        file_path = filedialog.askopenfilename(
            title="Otw√≥rz plik historii czatu",
            filetypes=(("Pliki tekstowe", "*.txt"), ("Wszystkie pliki", "*.*"))
        )
        if not file_path:
            return
            
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Parsowanie historii czatu
            chat_entries = []
            pattern = r'\[(.*?)\] (.*?):\n(.*?)(?=\n\n\[|$)'
            matches = re.findall(pattern, content, re.DOTALL)
            
            for match in matches:
                chat_entries.append({
                    "timestamp": match[0],
                    "role": match[1],
                    "content": match[2].strip()
                })
            
            self.loaded_chats.append({
                "path": file_path,
                "content": content,
                "entries": chat_entries
            })
            
            self.update_status(f"Za≈Çadowano plik czatu: {file_path}")
            self.update_chat_listbox()
            
        except Exception as e:
            messagebox.showerror("B≈ÇƒÖd", f"Nie uda≈Ço siƒô wczytaƒá pliku: {str(e)}")
    
    def update_chat_listbox(self):
        self.chat_listbox.delete(0, tk.END)
        for chat in self.loaded_chats:
            filename = os.path.basename(chat["path"])
            self.chat_listbox.insert(tk.END, filename)
    
    def display_selected_chat(self, event):
        if not self.loaded_chats:
            return
            
        selection = self.chat_listbox.curselection()
        if not selection:
            return
            
        index = selection[0]
        chat = self.loaded_chats[index]
        
        # Tworzenie nowego okna z pe≈ÇnƒÖ tre≈õciƒÖ czatu
        chat_window = tk.Toplevel(self.root)
        chat_window.title(f"Czat: {os.path.basename(chat['path'])}")
        chat_window.geometry("800x600")
        
        text_area = scrolledtext.ScrolledText(chat_window, wrap=tk.WORD)
        text_area.pack(fill="both", expand=True, padx=10, pady=10)
        text_area.insert(tk.END, chat["content"])
        text_area.configure(state="disabled")
        
        # Dodaj przycisk do skanowania ZIP
        tk.Button(
            chat_window, 
            text="Skanuj w poszukiwaniu ZIP", 
            command=lambda: self.scan_chat_for_zips(chat),
            bg="#FF9800", fg="white"
        ).pack(pady=10)
    
    def open_chat_directory(self):
        chat_dir = Path.home() / "chat_history"
        chat_dir.mkdir(exist_ok=True)
        webbrowser.open(f"file://{chat_dir}")
    
    def export_to_gpt(self):
        selection = self.chat_listbox.curselection()
        if not selection:
            messagebox.showinfo("Info", "Wybierz czat do eksportu")
            return
            
        index = selection[0]
        chat = self.loaded_chats[index]
        pyperclip.copy(chat["content"])
        self.update_status("Zawarto≈õƒá czatu skopiowana do schowka")
        messagebox.showinfo("Sukces", "Czat skopiowany do schowka. Mo≈ºesz go wkleiƒá bezpo≈õrednio do GPT!")
    
    def copy_chat_to_clipboard(self):
        selection = self.chat_listbox.curselection()
        if not selection:
            messagebox.showinfo("Info", "Wybierz czat do skopiowania")
            return
            
        index = selection[0]
        chat = self.loaded_chats[index]
        pyperclip.copy(chat["content"])
        self.update_status("Zawarto≈õƒá czatu skopiowana do schowka")
    
    # Funkcje zarzƒÖdzania plikami
    def scan_all_chats_for_zips(self):
        self.found_zips = []
        self.zip_listbox.delete(0, tk.END)
        
        for chat in self.loaded_chats:
            self.scan_chat_for_zips(chat, add_to_list=True)
        
        if not self.found_zips:
            messagebox.showinfo("Info", "Nie znaleziono link√≥w ZIP w ≈ºadnym czacie")
        else:
            self.update_status(f"Znaleziono {len(self.found_zips)} link√≥w ZIP w czatach")
    
    def scan_chat_for_zips(self, chat, add_to_list=False):
        # Wyszukaj wszystkie linki .zip w tek≈õcie
        zip_links = re.findall(r'https?://[^\s]+\.zip', chat["content"], re.IGNORECASE)
        
        if not zip_links:
            if not add_to_list:
                messagebox.showinfo("Info", "Nie znaleziono link√≥w .zip w tym czacie")
            return zip_links
        
        if add_to_list:
            self.found_zips.extend(zip_links)
            for link in zip_links:
                self.zip_listbox.insert(tk.END, link)
        
        return zip_links
    
    def download_all_zips(self):
        if not self.found_zips:
            messagebox.showinfo("Info", "Brak link√≥w ZIP do pobrania")
            return
            
        success_count = 0
        for link in self.found_zips:
            if self.download_zip(link):
                success_count += 1
        
        messagebox.showinfo("Sukces", f"Pobrano {success_count}/{len(self.found_zips)} plik√≥w ZIP")
    
    def open_zip_directory(self):
        zip_dir = Path.home() / "zip_downloads"
        zip_dir.mkdir(exist_ok=True)
        webbrowser.open(f"file://{zip_dir}")
    
    def show_zip_paths(self):
        if not self.downloaded_zips:
            messagebox.showinfo("Info", "Brak pobranych plik√≥w ZIP")
            return
            
        paths_window = tk.Toplevel(self.root)
        paths_window.title("≈öcie≈ºki do plik√≥w ZIP")
        paths_window.geometry("600x400")
        
        text_area = scrolledtext.ScrolledText(paths_window, wrap=tk.WORD)
        text_area.pack(fill="both", expand=True, padx=10, pady=10)
        
        for path in self.downloaded_zips:
            text_area.insert(tk.END, path + "\n")
        
        text_area.configure(state="disabled")
        
        tk.Button(
            paths_window, 
            text="Kopiuj ≈õcie≈ºki", 
            command=lambda: pyperclip.copy("\n".join(self.downloaded_zips)),
            bg="#4CAF50", fg="white"
        ).pack(pady=10)
    
    def extract_selected_zip(self):
        selection = self.zip_listbox.curselection()
        if not selection:
            messagebox.showinfo("Info", "Wybierz plik ZIP do rozpakowania")
            return
            
        index = selection[0]
        zip_path = self.downloaded_zips[index]
        
        extract_dir = filedialog.askdirectory(title="Wybierz folder do rozpakowania")
        if not extract_dir:
            return
            
        try:
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(extract_dir)
            
            self.update_status(f"Rozpakowano {zip_path} do {extract_dir}")
            messagebox.showinfo("Sukces", f"Plik ZIP zosta≈Ç rozpakowany do:\n{extract_dir}")
        except Exception as e:
            messagebox.showerror("B≈ÇƒÖd", f"Nie uda≈Ço siƒô rozpakowaƒá pliku: {str(e)}")

if __name__ == "__main__":
    root = tk.Tk()
    app = ChatManagerApp(root)
    root.mainloop()
Pe≈Çna lista funkcjonalno≈õci:
1. Monitorowanie w czasie rzeczywistym
Automatyczne wykrywanie link√≥w ZIP w schowku

Logowanie ca≈Çej historii czat√≥w z rozr√≥≈ºnieniem r√≥l

Rƒôczne sterowanie procesem monitorowania

2. ZarzƒÖdzanie archiwum czat√≥w
Wczytywanie zapisanych historii czat√≥w

PrzeglƒÖdanie pe≈Çnej tre≈õci czat√≥w w osobnych oknach

Eksport czat√≥w do GPT (kopiowanie do schowka)

Otwieranie katalogu z historiƒÖ czat√≥w

3. Zaawansowane zarzƒÖdzanie plikami
Skanowanie czat√≥w w poszukiwaniu link√≥w ZIP

Zbiorcze pobieranie wszystkich znalezionych plik√≥w ZIP

PrzeglƒÖdanie pobranych plik√≥w ZIP

Rozpakowywanie archiw√≥w ZIP

Wy≈õwietlanie pe≈Çnych ≈õcie≈ºek do plik√≥w

4. Integracja z systemem
Automatyczne tworzenie katalog√≥w:

chat_history - przechowuje wszystkie zapisane czaty

zip_downloads - przechowuje pobrane archiwa ZIP

Otwieranie folder√≥w w eksploratorze plik√≥w

Kopiowanie ≈õcie≈ºek do schowka

Jak korzystaƒá z aplikacji:
Monitorowanie czat√≥w:

Uruchom aplikacjƒô

Kliknij "Start Logging" w zak≈Çadce Monitorowanie

Kopiuj fragmenty rozm√≥w z ChatGPT/DeepSeek

Aplikacja automatycznie rozpozna role i zapisze historiƒô

Zapisywanie i wczytywanie czat√≥w:

U≈ºyj "Zapisz Czat" aby zapisaƒá bie≈ºƒÖcƒÖ rozmowƒô

W zak≈Çadce Archiwum wczytaj zapisane czaty

PrzeglƒÖdaj pe≈Çne historie rozm√≥w

Pobieranie i zarzƒÖdzanie plikami ZIP:

W zak≈Çadce Pliki kliknij "Skanuj wszystkie czaty"

Aplikacja znajdzie wszystkie linki ZIP w historii

U≈ºyj "Pobierz wszystkie" aby ≈õciƒÖgnƒÖƒá archiwa

Rozpakuj wybrane pliki ZIP

Eksport do GPT:

Wybierz czat w zak≈Çadce Archiwum

Kliknij "Eksportuj do GPT"

Wklej zawarto≈õƒá schowka do nowego czatu w GPT

Wymagania instalacyjne:
bash
pip install requests pyperclip
Ta aplikacja zapewnia kompleksowe rozwiƒÖzanie do zarzƒÖdzania ca≈ÇƒÖ historiƒÖ rozm√≥w z AI oraz plikami, kt√≥re sƒÖ w nich udostƒôpniane. Wszystkie dane sƒÖ przechowywane lokalnie, a u≈ºytkownik ma pe≈ÇnƒÖ kontrolƒô nad procesem monitorowania i zarzƒÖdzania plikami.