Oto rozszerzona aplikacja z funkcj monitorowania czat贸w i zapisywania historii:

python
import os
import time
import requests
import pyperclip
import json
import tkinter as tk
from tkinter import scrolledtext, messagebox
from datetime import datetime
from pathlib import Path
from urllib.parse import unquote

class ClipboardMonitorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Clipboard Monitor Pro")
        self.root.geometry("700x600")
        self.root.resizable(True, True)
        
        self.monitoring = False
        self.chat_logging = False
        self.chat_history = []
        self.last_clip = ""
        
        # Stylizacja
        self.root.configure(bg="#f0f0f0")
        button_style = {"font": ("Arial", 10), "bg": "#4CAF50", "fg": "white", "height": 1, "width": 15}
        frame_style = {"bd": 2, "relief": "groove", "padx": 10, "pady": 10, "bg": "white"}
        
        # Ramka dla funkcji ZIP
        zip_frame = tk.LabelFrame(root, text=" ZIP Downloader", **frame_style)
        zip_frame.pack(fill="x", padx=10, pady=5)
        
        tk.Button(zip_frame, text=" Start Monitoring", command=self.start_monitoring, **button_style).pack(side="left", padx=5, pady=5)
        tk.Button(zip_frame, text="癸 Stop", command=self.stop_monitoring, **button_style).pack(side="left", padx=5, pady=5)
        tk.Label(zip_frame, text="Status:", bg="white").pack(side="left", padx=5)
        self.zip_status = tk.Label(zip_frame, text="Nieaktywny", fg="red", bg="white")
        self.zip_status.pack(side="left", padx=5)
        
        # Ramka dla funkcji czatu
        chat_frame = tk.LabelFrame(root, text=" Chat Logger", **frame_style)
        chat_frame.pack(fill="x", padx=10, pady=5)
        
        tk.Button(chat_frame, text=" Start Chat Logging", command=self.start_chat_logging, **button_style).pack(side="left", padx=5, pady=5)
        tk.Button(chat_frame, text="癸 Stop Logging", command=self.stop_chat_logging, **button_style).pack(side="left", padx=5, pady=5)
        tk.Button(chat_frame, text=" Save Chat", command=self.save_chat, **button_style).pack(side="left", padx=5, pady=5)
        tk.Label(chat_frame, text="Status:", bg="white").pack(side="left", padx=5)
        self.chat_status = tk.Label(chat_frame, text="Nieaktywny", fg="red", bg="white")
        self.chat_status.pack(side="left", padx=5)
        
        # Wywietlacz historii czatu
        self.chat_display = scrolledtext.ScrolledText(root, wrap=tk.WORD, font=("Arial", 10))
        self.chat_display.pack(fill="both", expand=True, padx=10, pady=5)
        self.chat_display.insert(tk.END, "Historia czatu bdzie wywietlana tutaj...\n")
        self.chat_display.configure(state="disabled")
        
        # Status bar
        self.status_bar = tk.Label(root, text="Gotowy", bd=1, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Uruchom g贸wn ptl
        self.update_clipboard()
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

    def start_monitoring(self):
        self.monitoring = True
        self.zip_status.config(text="Aktywny", fg="green")
        self.update_status("Monitorowanie ZIP wczone")

    def stop_monitoring(self):
        self.monitoring = False
        self.zip_status.config(text="Nieaktywny", fg="red")
        self.update_status("Monitorowanie ZIP wyczone")

    def start_chat_logging(self):
        self.chat_logging = True
        self.chat_status.config(text="Aktywny", fg="green")
        self.update_status("Logowanie czatu wczone")
        self.add_chat_entry("System", "Rozpoczto logowanie czatu")

    def stop_chat_logging(self):
        self.chat_logging = False
        self.chat_status.config(text="Nieaktywny", fg="red")
        self.update_status("Logowanie czatu wyczone")
        self.add_chat_entry("System", "Zatrzymano logowanie czatu")

    def download_zip(self, url):
        try:
            # Oczyszczanie nazwy pliku z URL
            filename = unquote(url.split("/")[-1])
            if not filename.endswith('.zip'):
                filename += '.zip'
            
            # Tworzenie folderu pobierania
            download_dir = Path.home() / "zip_downloads"
            download_dir.mkdir(exist_ok=True)
            file_path = download_dir / filename
            
            # Pobieranie pliku
            self.update_status(f"Pobieranie: {url}")
            response = requests.get(url, stream=True)
            response.raise_for_status()
            
            with open(file_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            self.update_status(f"Zapisano: {file_path}")
            return True
            
        except Exception as e:
            self.update_status(f"Bd: {str(e)}")
            return False

    def add_chat_entry(self, role, content):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        entry = {
            "timestamp": timestamp,
            "role": role,
            "content": content
        }
        self.chat_history.append(entry)
        
        # Aktualizacja wywietlacza
        self.chat_display.configure(state="normal")
        self.chat_display.insert(tk.END, f"[{timestamp}] {role}:\n{content}\n\n")
        self.chat_display.configure(state="disabled")
        self.chat_display.yview(tk.END)

    def save_chat(self):
        try:
            if not self.chat_history:
                messagebox.showinfo("Info", "Brak historii czatu do zapisania")
                return
                
            chat_dir = Path.home() / "chat_history"
            chat_dir.mkdir(exist_ok=True)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            file_path = chat_dir / f"chat_{timestamp}.txt"
            
            with open(file_path, 'w', encoding='utf-8') as f:
                for entry in self.chat_history:
                    f.write(f"[{entry['timestamp']}] {entry['role']}:\n")
                    f.write(f"{entry['content']}\n\n")
            
            self.update_status(f"Zapisano histori czatu: {file_path}")
            messagebox.showinfo("Sukces", f"Historia czatu zapisana w:\n{file_path}")
            
        except Exception as e:
            messagebox.showerror("Bd", f"Nie udao si zapisa czatu: {str(e)}")

    def update_status(self, message):
        self.status_bar.config(text=message)
        print(message)

    def update_clipboard(self):
        try:
            current_clip = pyperclip.paste().strip()
            
            # Monitorowanie ZIP
            if (self.monitoring and 
                current_clip != self.last_clip and 
                current_clip.startswith(('http://', 'https://')) and 
                '.zip' in current_clip.lower()):
                
                if self.download_zip(current_clip):
                    self.last_clip = current_clip
                else:
                    self.last_clip = ""
            
            # Monitorowanie czatu
            if (self.chat_logging and 
                current_clip != self.last_clip and 
                current_clip and 
                len(current_clip) > 10):
                
                # Automatyczne wykrywanie roli na podstawie typowych wzorc贸w
                role = "User"
                if any(phrase in current_clip for phrase in ["Assistant:", "AI:", "ChatGPT:", "DeepSeek:"]):
                    role = "Assistant"
                
                self.add_chat_entry(role, current_clip)
                self.last_clip = current_clip
        
        except Exception as e:
            self.update_status(f"Bd monitorowania: {str(e)}")
        
        self.root.after(1000, self.update_clipboard)

    def on_closing(self):
        if self.chat_logging:
            self.stop_chat_logging()
        self.root.destroy()

if __name__ == "__main__":
    root = tk.Tk()
    app = ClipboardMonitorApp(root)
    root.mainloop()
Funkcjonalnoci monitorowania czatu:
Automatyczne wykrywanie r贸l:

System rozpoznaje czy wiadomo pochodzi od u偶ytkownika czy asystenta

Wykrywa typowe oznaczenia: "Assistant:", "AI:", "ChatGPT:", "DeepSeek:"

Formatowanie historii:

plaintext
[2024-07-30 14:25:36] User:
Jak dziaa ta aplikacja?

[2024-07-30 14:26:01] Assistant:
Aplikacja monitoruje schowek i zapisuje...
Zapis do pliku:

Pliki tekstowe zapisywane w folderze chat_history

Nazwy plik贸w zawieraj znacznik czasu: chat_20240730_142536.txt

Podgld na 偶ywo:

Wbudowany wywietlacz z przewijaniem pokazujcy ca histori czatu

Automatyczne przewijanie do najnowszej wiadomoci

Jak korzysta:
Rozpoczcie logowania:

Kliknij " Start Chat Logging"

Aplikacja zacznie monitorowa schowek

Kopiowanie czatu:

Zaznacz i skopiuj (Ctrl+C) fragmenty rozmowy z ChatGPT/DeepSeek

Aplikacja automatycznie rozpozna autora i doda do historii

Zapis czatu:

Kliknij " Save Chat" aby zapisa ca histori do pliku

Pliki s zapisywane w C:\Users\twoja_nazwa\chat_history\

Kontynuacja rozmowy:

W nowym czacie wklej zawarto zapisanego pliku

Mo偶esz kontynuowa rozmow z penym kontekstem

Bezpieczestwo i kontrola:
Dane s przechowywane lokalnie

Logowanie wymaga rcznego wczenia

Pena kontrola przez przyciski start/stop

Brak ledzenia po zamkniciu aplikacji

Wymagania instalacyjne:
bash
pip install requests pyperclip
Aplikacja dziaa w trybie okienkowym (Windows/Mac/Linux) i czy funkcj pobierania plik贸w ZIP z zaawansowanym logowaniem czat贸w AI.