Oto usprawniona aplikacja, kt√≥ra specjalizuje siƒô w pobieraniu i konwertowaniu plik√≥w wideo, w szczeg√≥lno≈õci do formatu MP4:

python
import os
import re
import time
import requests
import pyperclip
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
from pathlib import Path
from urllib.parse import unquote, urlparse
from datetime import datetime
import subprocess
import threading
import sys

class VideoDownloader:
    def __init__(self, root):
        self.root = root
        self.root.title("Video Downloader & Converter")
        self.root.geometry("900x700")
        self.root.resizable(True, True)
        
        # Konfiguracja
        self.monitoring = False
        self.last_clip = ""
        self.downloaded_files = []
        self.ffmpeg_path = self.find_ffmpeg()
        
        # Tworzenie interfejsu
        self.create_ui()
        
        # Uruchom g≈Ç√≥wnƒÖ pƒôtlƒô
        self.update_clipboard()
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def create_ui(self):
        # G≈Ç√≥wny frame
        main_frame = tk.Frame(self.root, padx=10, pady=10)
        main_frame.pack(fill="both", expand=True)
        
        # Panel monitorowania
        monitor_frame = tk.LabelFrame(main_frame, text="üé¨ Pobieranie Wideo", padx=10, pady=10)
        monitor_frame.pack(fill="x", pady=(0, 10))
        
        tk.Button(monitor_frame, text="üöÄ Start Monitoring", command=self.start_monitoring,
                 bg="#4CAF50", fg="white", height=1, width=15).grid(row=0, column=0, padx=5, pady=5)
        tk.Button(monitor_frame, text="‚èπÔ∏è Stop", command=self.stop_monitoring,
                 bg="#F44336", fg="white", height=1, width=15).grid(row=0, column=1, padx=5, pady=5)
        
        self.monitor_status = tk.Label(monitor_frame, text="Status: Nieaktywny", fg="red")
        self.monitor_status.grid(row=0, column=2, padx=10)
        
        # Konfiguracja
        config_frame = tk.Frame(main_frame)
        config_frame.pack(fill="x", pady=(0, 10))
        
        tk.Label(config_frame, text="Folder pobierania:").grid(row=0, column=0, padx=5, sticky="w")
        self.download_dir_var = tk.StringVar(value=str(Path.home() / "Videos"))
        tk.Entry(config_frame, textvariable=self.download_dir_var, width=50).grid(row=0, column=1, padx=5)
        tk.Button(config_frame, text="PrzeglƒÖdaj", command=self.browse_directory).grid(row=0, column=2, padx=5)
        
        # Panel konwersji
        convert_frame = tk.LabelFrame(main_frame, text="üîß Konwersja Wideo", padx=10, pady=10)
        convert_frame.pack(fill="x", pady=(0, 10))
        
        tk.Label(convert_frame, text="Plik ≈∫r√≥d≈Çowy:").grid(row=0, column=0, padx=5, sticky="w")
        self.video_path_var = tk.StringVar()
        tk.Entry(convert_frame, textvariable=self.video_path_var, width=50).grid(row=0, column=1, padx=5)
        tk.Button(convert_frame, text="Wybierz", command=self.browse_video_file).grid(row=0, column=2, padx=5)
        
        tk.Label(convert_frame, text="Bitrate (kbps):").grid(row=1, column=0, padx=5, sticky="w")
        self.bitrate_var = tk.StringVar(value="800")
        tk.Entry(convert_frame, textvariable=self.bitrate_var, width=10).grid(row=1, column=1, padx=5, sticky="w")
        
        tk.Button(convert_frame, text="Konwertuj do MP4", command=self.convert_video,
                 bg="#2196F3", fg="white", height=1, width=15).grid(row=1, column=2, padx=5, pady=5)
        
        # Lista pobranych plik√≥w
        file_frame = tk.LabelFrame(main_frame, text="üìÇ Pobrane Pliki", padx=10, pady=10)
        file_frame.pack(fill="both", expand=True)
        
        self.file_listbox = tk.Listbox(file_frame)
        self.file_listbox.pack(fill="both", expand=True, padx=5, pady=5)
        self.file_listbox.bind("<Double-Button-1>", self.open_selected_file)
        
        # Przyciski zarzƒÖdzania
        btn_frame = tk.Frame(file_frame)
        btn_frame.pack(fill="x", pady=5)
        
        tk.Button(btn_frame, text="Otw√≥rz folder", command=self.open_download_directory,
                 bg="#FF9800", fg="white").pack(side="left", padx=5)
        tk.Button(btn_frame, text="Kopiuj ≈õcie≈ºkƒô", command=self.copy_file_path,
                 bg="#9C27B0", fg="white").pack(side="left", padx=5)
        tk.Button(btn_frame, text="Odtw√≥rz", command=self.play_selected_file,
                 bg="#4CAF50", fg="white").pack(side="left", padx=5)
        
        # Status bar
        self.status_bar = tk.Label(self.root, text="Gotowy", bd=1, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
    
    def start_monitoring(self):
        self.monitoring = True
        self.monitor_status.config(text="Status: Aktywny", fg="green")
        self.update_status("Rozpoczƒôto monitorowanie schowka - szukam link√≥w wideo")
    
    def stop_monitoring(self):
        self.monitoring = False
        self.monitor_status.config(text="Status: Nieaktywny", fg="red")
        self.update_status("Zatrzymano monitorowanie schowka")
    
    def browse_directory(self):
        directory = filedialog.askdirectory()
        if directory:
            self.download_dir_var.set(directory)
    
    def browse_video_file(self):
        file_path = filedialog.askopenfilename(
            filetypes=[("Pliki wideo", "*.mp4 *.mov *.avi *.mkv"), ("Wszystkie pliki", "*.*")]
        )
        if file_path:
            self.video_path_var.set(file_path)
    
    def update_status(self, message):
        self.status_bar.config(text=message)
        print(message)
    
    def download_video(self, url):
        try:
            # Sprawd≈∫ czy to link do wideo
            if not any(ext in url.lower() for ext in ['.mp4', '.mov', '.avi', '.mkv']):
                return False
            
            # Oczyszczanie nazwy pliku z URL
            parsed = urlparse(url)
            filename = unquote(parsed.path.split("/")[-1])
            
            # Tworzenie folderu pobierania
            download_dir = Path(self.download_dir_var.get())
            download_dir.mkdir(exist_ok=True, parents=True)
            file_path = download_dir / filename
            
            # Sprawd≈∫ czy plik ju≈º istnieje
            if file_path.exists():
                self.update_status(f"Plik ju≈º istnieje: {file_path}")
                self.downloaded_files.append(str(file_path))
                self.update_file_listbox()
                return True
            
            # Pobieranie pliku
            self.update_status(f"Pobieranie wideo: {url}")
            response = requests.get(url, stream=True)
            response.raise_for_status()
            
            with open(file_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            self.update_status(f"Pobrano wideo: {file_path}")
            self.downloaded_files.append(str(file_path))
            self.update_file_listbox()
            
            # Automatyczna konwersja dla plik√≥w MOV
            if file_path.suffix.lower() == ".mov":
                self.update_status("Rozpoczynam konwersjƒô MOV ‚Üí MP4")
                self.convert_video(str(file_path))
            
            return True
            
        except Exception as e:
            self.update_status(f"B≈ÇƒÖd pobierania: {str(e)}")
            return False
    
    def update_file_listbox(self):
        self.file_listbox.delete(0, tk.END)
        for file_path in self.downloaded_files:
            self.file_listbox.insert(tk.END, file_path)
    
    def open_download_directory(self):
        download_dir = Path(self.download_dir_var.get())
        if download_dir.exists():
            if sys.platform == "win32":
                os.startfile(str(download_dir))
            elif sys.platform == "darwin":
                subprocess.Popen(["open", str(download_dir)])
            else:
                subprocess.Popen(["xdg-open", str(download_dir)])
        else:
            messagebox.showerror("B≈ÇƒÖd", "Folder nie istnieje!")
    
    def open_selected_file(self, event):
        selection = self.file_listbox.curselection()
        if not selection:
            return
            
        index = selection[0]
        file_path = Path(self.downloaded_files[index])
        
        if file_path.exists():
            if sys.platform == "win32":
                os.startfile(str(file_path))
            elif sys.platform == "darwin":
                subprocess.Popen(["open", str(file_path)])
            else:
                subprocess.Popen(["xdg-open", str(file_path)])
        else:
            messagebox.showerror("B≈ÇƒÖd", "Plik nie istnieje!")
    
    def play_selected_file(self):
        selection = self.file_listbox.curselection()
        if not selection:
            return
            
        index = selection[0]
        file_path = Path(self.downloaded_files[index])
        
        if file_path.exists():
            if file_path.suffix.lower() in ['.mp4', '.mov', '.avi', '.mkv']:
                if sys.platform == "win32":
                    os.startfile(str(file_path))
                elif sys.platform == "darwin":
                    subprocess.Popen(["open", str(file_path)])
                else:
                    subprocess.Popen(["xdg-open", str(file_path)])
            else:
                messagebox.showinfo("Info", "To nie jest plik wideo")
        else:
            messagebox.showerror("B≈ÇƒÖd", "Plik nie istnieje!")
    
    def copy_file_path(self):
        selection = self.file_listbox.curselection()
        if not selection:
            return
            
        index = selection[0]
        file_path = self.downloaded_files[index]
        pyperclip.copy(file_path)
        self.update_status(f"Skopiowano ≈õcie≈ºkƒô: {file_path}")
    
    def find_ffmpeg(self):
        # Sprawd≈∫ standardowe lokalizacje ffmpeg
        possible_paths = [
            "ffmpeg",
            "ffmpeg.exe",
            "/usr/bin/ffmpeg",
            "/usr/local/bin/ffmpeg",
            "C:\\ffmpeg\\bin\\ffmpeg.exe"
        ]
        
        for path in possible_paths:
            try:
                subprocess.run([path, "-version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
                return path
            except:
                continue
        
        return None
    
    def convert_video(self, input_path=None):
        if not input_path:
            input_path = self.video_path_var.get()
        
        if not input_path:
            messagebox.showerror("B≈ÇƒÖd", "Wybierz plik wideo do konwersji!")
            return
            
        input_path = Path(input_path)
        download_dir = Path(self.download_dir_var.get())
        
        if not input_path.exists():
            messagebox.showerror("B≈ÇƒÖd", "Plik wej≈õciowy nie istnieje!")
            return
        
        # Przygotuj nazwƒô pliku wyj≈õciowego
        output_path = download_dir / f"{input_path.stem}.mp4"
        
        # Przygotuj polecenie ffmpeg
        bitrate = self.bitrate_var.get()
        
        cmd = [
            self.ffmpeg_path,
            "-i", str(input_path),
            "-c:v", "libx264",
            "-b:v", f"{bitrate}k",
            "-movflags", "+faststart",
            "-y",  # Nadpisz istniejƒÖcy plik
            str(output_path)
        ]
        
        # Uruchom konwersjƒô w osobnym wƒÖtku
        threading.Thread(target=self.run_conversion, args=(cmd, input_path, output_path), daemon=True).start()
    
    def run_conversion(self, cmd, input_path, output_path):
        try:
            self.update_status(f"Rozpoczƒôto konwersjƒô: {input_path} ‚Üí {output_path}")
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                bufsize=1,
                encoding='utf-8',
                errors='replace'
            )
            
            # Wy≈õwietlaj postƒôp
            while True:
                line = process.stdout.readline()
                if not line:
                    break
                # Wykrywanie postƒôpu konwersji
                if "time=" in line:
                    time_match = re.search(r"time=(\d+:\d+:\d+\.\d+)", line)
                    if time_match:
                        self.update_status(f"Konwersja... {time_match.group(1)}")
            
            process.communicate()
            
            if process.returncode == 0:
                self.update_status(f"Konwersja zako≈Ñczona: {output_path}")
                self.downloaded_files.append(str(output_path))
                self.update_file_listbox()
                messagebox.showinfo("Sukces", f"Wideo skonwertowane do:\n{output_path}")
            else:
                self.update_status(f"B≈ÇƒÖd konwersji! Kod: {process.returncode}")
                messagebox.showerror("B≈ÇƒÖd", "Konwersja nie powiod≈Ça siƒô")
        
        except Exception as e:
            self.update_status(f"B≈ÇƒÖd konwersji: {str(e)}")
            messagebox.showerror("B≈ÇƒÖd", f"Nie uda≈Ço siƒô przekonwertowaƒá wideo: {str(e)}")
    
    def update_clipboard(self):
        try:
            current_clip = pyperclip.paste().strip()
            
            if (self.monitoring and 
                current_clip != self.last_clip and 
                current_clip.startswith(('http://', 'https://'))):
                
                if self.download_video(current_clip):
                    self.last_clip = current_clip
                else:
                    self.last_clip = ""
        
        except Exception as e:
            self.update_status(f"B≈ÇƒÖd monitorowania: {str(e)}")
        
        self.root.after(1000, self.update_clipboard)
    
    def on_closing(self):
        if self.monitoring:
            self.stop_monitoring()
        self.root.destroy()

if __name__ == "__main__":
    root = tk.Tk()
    app = VideoDownloader(root)
    root.mainloop()
Instrukcja dla Twojego przypadku:
Pobierz demo.mov z czatu:

Uruchom aplikacjƒô

Kliknij "üöÄ Start Monitoring"

Skopiuj link do pliku demo.mov z czatu

Aplikacja automatycznie pobierze plik do folderu wideo

Automatyczna konwersja do MP4:

Po pobraniu pliku MOV aplikacja automatycznie uruchomi konwersjƒô do MP4

Skonwertowany plik pojawi siƒô w tym samym folderze jako demo.mp4

Rƒôczna konwersja (je≈õli potrzebujesz):

Kliknij "Wybierz" i wybierz plik .mov do konwersji

Ustaw bitrate (domy≈õlnie 800k)

Kliknij "Konwertuj do MP4"

Kluczowe funkcje:
Specjalizacja w plikach wideo:

Automatyczne wykrywanie link√≥w do wideo (.mp4, .mov, .avi, .mkv)

Pobieranie bezpo≈õrednio do folderu wideo

Automatyczna konwersja:

Natychmiastowa konwersja MOV ‚Üí MP4 po pobraniu

Optymalne ustawienia dla webu: -movflags +faststart

Konfigurowalny bitrate

ZarzƒÖdzanie plikami:

Lista pobranych plik√≥w

Podw√≥jne klikniƒôcie - otw√≥rz plik

"Odtw√≥rz" - odtwarza plik wideo w domy≈õlnej aplikacji

"Otw√≥rz folder" - pokazuje lokalizacjƒô plik√≥w

Wymagania:

Aplikacja pr√≥buje automatycznie znale≈∫ƒá ffmpeg

Je≈õli nie znajdzie, pobierz ffmpeg z https://ffmpeg.org/

Umie≈õƒá ffmpeg.exe w C:\ffmpeg\bin\ lub dodaj do PATH

Jak dzia≈Ça konwersja wideo:
Aplikacja u≈ºywa polecenia:

bash
ffmpeg -i input.mov -c:v libx264 -b:v 800k -movflags +faststart -y output.mp4
Parametry:

-c:v libx264 - kodek H.264

-b:v 800k - bitrate 800 kbps (mo≈ºesz zmieniƒá w aplikacji)

-movflags +faststart - optymalizacja do streamingu

-y - nadpisz istniejƒÖcy plik

Dla Twojego przypadku demo:
Pobierz demo.mov z linku podanego w czacie

Aplikacja automatycznie przekonwertuje do demo.mp4

U≈ºyj skonwertowanego pliku w swoim projekcie:

html
<video controls width="100%">
  <source src="assets/demo.mp4" type="video/mp4">
  Twoja przeglƒÖdarka nie obs≈Çuguje wideo HTML5.
</video>
Bezpiecze≈Ñstwo:
Wszystkie operacje lokalne

Brak wysy≈Çania danych na zewnƒÖtrz

Pe≈Çna kontrola nad pobieranymi plikami

To rozwiƒÖzanie pozwala szybko pobraƒá i przygotowaƒá pliki wideo z czat√≥w do u≈ºycia w projektach webowych.